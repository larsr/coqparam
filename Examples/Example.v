(**************************************************************************)
(*                                                                        *)
(*     CoqParam                                                           *)
(*     Copyright (C) 2012                                                 *)
(*                                                                        *)
(*     Chantal Keller                                                     *)
(*     Marc Lasson                                                        *)
(*                                                                        *)
(*     INRIA - École Polytechnique - ÉNS de Lyon                          *)
(*                                                                        *)
(*   This file is distributed under the terms of the GNU Lesser General   *)
(*   Public License                                                       *)
(*                                                                        *)
(**************************************************************************)


Add LoadPath "..".


(* This commands loads the Coq plugin *)

Declare ML Module "abstraction".


(* [Abstraction] is a vernacular command that takes as arguments:
     - a constant, an inductive or a term n
     - a list of identifiers of length:
       - 0 or 1 in the case of a constant
       - 0 or (number of inductives and constructors) in the case of an
       inductive
       - 1 in the case of a term.
   It computes the parametricity relation generated by the type of n,
   and a proof that n satifies it. The proof is placed in the
   identifiers if some are given, or in arbitrary identifiers otherwise.
   *)

Definition unit := forall A:Prop,A -> A.
Abstraction unit unit_R.
Print unit_R.

Definition id : unit := (fun (A:Prop) (x:A) => x).
Abstraction id.
Check id_R.

Abstraction (forall A:Prop, A) false_R.
Check false_R.

Abstraction nat.
Print nat_R.

Abstraction nat nat_R2 O_R2 S_R2.
Print nat_R2.


(* This section is an example of the [param] tactic. Its syntax is
   [param t as n], and it behaves like [Abstraction t n], inside a Coq
   proof. *)

Section Church.

  Fixpoint iter k (α : Set) f z : α :=
    match k with
      | 0 => z
      | S p => f (iter p α f z)
    end.

  Lemma church_exists :
    let f := (fun (A:Set) (f:A -> A) (z:A) => f (f z)) in
      exists k:nat,
      forall (α : Set) (g : α -> α) z,
        iter k α g z = f α g z.
    intro f.
    exists (f nat S O).
    param (fun (A:Set) (f:A -> A) (z:A) => f (f z)) as H.
    intros α g z; apply (H α nat).
    intros H0 H1 H2; simpl; rewrite H2; reflexivity.
    reflexivity.
  Qed.

  Print church_exists.

  Print Assumptions church_exists.

End Church.
